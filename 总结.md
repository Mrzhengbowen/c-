###1.STL:
    (1).vector
    (2).set
    (3).queue
    (4).stack
    (5).string

###2.库:
    (1).#include<stdio.h>
        scanf()
        printf()
        getchar()
        putchar()
        gets()
        puts()
        sscanf()
        sprintf()

    (2)#include<stdlib.h>

    (3)#include<time.h>
    
    (4)#include<math.h>
        fabs()
        sqrt()
        pow()
        floor()
        ceil()
        round()

    (5)#include<algorithm>
        max()、min()、abs()
        swap()
        reverse()
        next_permutation()
        fill()
        sort()
        lower_bound(),upper_bound()

###3.位运算
    (1) 与 &
        或 |
        反 ~
        异或 ^
    (2) 左移<<
        右移>>
    (3) 原码
        反码
        补码
    (4)位运算判断奇偶数

    (5)判断二进制位是1还是0

    (6)异或法交换两个整形变量的值

    (7)不用判断语句，求整数的绝对值

    (8)例题：如何找数组中唯一成对的那个数
    (9)例题：找出落单的那个数
    (11)例题：二进制中1的个数
    (12)例题：是不是2的整数次方
    (13)例题：将整数的奇偶位互换

###4.递归
    关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件,如求n的阶乘
    (1)找重复-->找子问题 4321
    (2)找变化-->找重复中的变化量作为参数 n变化
    (3)找边界-->找参数变化趋势设计出口  n=1截止

###5.树
![alt text](image\summarize\树.png)

    1.树的概念
        (1)节点的度：一个节点含有的子树的个数称为该节点的度；如上图：A的度为6
        (2)叶节点或终端节点：度为0的节点称为叶节点；如上图：B、C、H、I...等节点为叶节点
        (3)非终端节点或分支节点：度不为0的节点；如上图：D、E、F、G...等节点为分支节点
        (4)双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；如上图：A是B的父节点
        (5)孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；如上图：B是A的孩子节点
        (6)兄弟节点：具有相同父节点的节点互称为兄弟节点；如上图：B、C是兄弟节点
        (7)树的度：一棵树中，最大的节点的度称为树的度；如上图：树的度为6
        (8)节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
        (9)树的高度或深度：树中节点的最大层次；如上图：树的高度为4
        (10)节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
        (11)子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
        (12)森林：由m（m>0）棵互不相交的多颗树的集合称为森林；（数据结构中的学习并查集本质就是一个森林）

    2.树的表示：
        (1)双亲表示法
        (2)孩子表示法
        (3)孩子兄弟表示法
    3.二叉树
        (1)存储结构
        (2)满二叉树,完全二叉树,二叉搜索数
        (3)性质
           性质一：若规定根节点的层数为1，则一棵非空二叉树的第 i 层上最多有 2 ^ (i - 1) 个节点（满二叉树）
           性质二：若规定根节点的层数为1，则深度为 h 的二叉树的最大节点数是2 ^ h - 1（满二叉树）
           性质三：对任何一棵二叉树，如果度为0的叶节点个数是X0，度为2的节点个数是X2，则 X0 =  X2 + 1；
           性质四：若规定根节点的层数是1，具有 n 个节点的满二叉树的深度为 h = log ( n + 1) 

        (4)二叉树遍历
            前序（先根）遍历：根节点、左子树、右子树 (递归,非递归)
            中序（中根）遍历：左子树、根节点、右子树
            后序（后根）遍历：左子树、右子树、根节点
            层序遍历：BFS


###6.分治
![alt text](image\summarize\分治.jpg)

        (1)分解成子问题->递归处理子问题->合并子题
        (2)如归并排序(手写一下)
        (3)列题：计算pow(x, n)


#1.go to 用法：
====
             cout << 1.xxxx <<endl;
             cout << 2.xxxx <<endl;
             goto FLAG
             cout << 3.xxxx <<endl;
             cout << 4.xxxx <<endl;
             FLAG:
             cout << 5.xxxx <<endl;
             //运算一和二行然后跳转到第5个
   
   
   #2.数组：
====
       //数组
       /*
       1.数据类型  数组名[数组长度]
       2.数据类型  数组名[数组长度] = {值1，值2。。。}；
       3.数据类型  数组名[] = {值1，值2.....};
       */


       //1.数据类型  数组名[数组长度]
       int arr[5];
       //给数组中的元素进行赋值
       //数组元素下标从0开始索引
       arr[0] = 10;
       arr[1] = 20;
       arr[2] = 30;
       arr[3] = 40;
       arr[4] = 50;
       //访问数组元素
       cout << arr[0] <<endl;

       //2.数据类型  数组名[数组长度] = {值1，值2。。。}
       //如果在初始化数据的时候没有填补完，后面会自动用0来填补；int arr2[5] = {10,20,30}
       int arr2[5] =  {10,20,30,40,50};

       cout << arr2[0] <<endl;
       cout << arr2[1] <<endl;
       cout << arr2[2] <<endl;
       cout << arr2[3] <<endl;
       cout << arr2[4] <<endl;
       //可以利用循环来输出数组中的元素
       for(int i =0;i<5;i++){
            cout << arr2[i] <<endl; 
       }

       //3.数据类型  数组名[] = {值1，值2.....};
         int arr3[] =  {10,20,30,40,50,60,70};
       
       //数组名的用途
       int arr[10] = {1,2,3,4,5,6,7,8,9,10}
       cout << "整个数组占用内存" << sizeof(arr) <<endl;//40
       cout << "每个数组占用内存" << sizeof(arr[0]) <<endl;
       cout << "数组中元素个数为：" << sizeof(arr)/sizeof(arr[0]) <<endl;
       // arr = 100;错误，数组名是常量，因此不可以赋值
       
       int end = sizeof(arr) / sizeof(arr[0]) - 1 //末尾元素下标
       #属猪逆置如下：
      while(start<end){
       //实现数组元素的逆置
       int arr[5] = {1,3,2,5,4}
       int start = 0;
       int end = sizeof(arr)/sizeof(arr[0]) - 1;//结束下标
       int temp = arr[start];
       arr[start] = arr[end];
       arr[end] = arr[temp];
       //更新下标
       start ++;
       end --;
       }
       
       
  #冒泡排序：
  =
  
      //利用冒泡排序实现升序序列
      int arr[9] = {4,2,8,0,5,7,1,3,9}
      //总共排序轮数为元素个数 - 1
      for (int i =0 ; i < 9-1 ; i++){
            //内存循环对比,次数 = 元素个数 - 当前轮数 - 1
            for(int j = 0 ; j<9-i-1;j++){
            //如果第一个数字比第二个数字大，交换两个数字
             if(arr[j]>arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
             }

             }

      }
